# 1. 컴퓨터구조란?

컴퓨터 시스템의 동작 원리 & 구성 요소 간 상호작용을 나타내는 일종의 설계도

- 컴퓨터가 명령을 처리하고 결과를 내는 것
- HW와 SW가 소통하는 것

→ 효율적인 동작을 위한 설계 (속도, 전력, 병렬처리, HW 효율 등)

## 주요 계층

![Image](https://github.com/user-attachments/assets/e90ad93f-b94c-4c32-874a-78284cdecda1)
| 계층 | 설명 |
| --- | --- |
| ISA | HW가 이해하는 명령의 집합 (HW-SW 간 인터페이스) |
| Micro Architecture | 주어진 ISA를 실제로 어떻게 구현할지에 대한 구조 (파이프라인, 캐시, 레지스터 설계 등) |
| HW | Physical Layer (실제 회로, 트랜지스터, 메모리 셀 등) |


# 2. CPU

> CPU는 메모리의 특정 위치에 저장되어 있는 명령을 불러와 처리함
> 

연산을 수행하기 위해 임시 저장 장치인 Register를 사용함

### 처리 예시

- 두 레지스터에 저장된 값을 더해 다른 레지스터에 저장
- 한 레지스터가 메모리 상의 주소를 가리킬 때, 이 주소에 저장된 값을 다른 레지스터로 불러옴
- 한 레지스터가 메모리 상의 주소를 가리킬 때, 다른 레지스터에 저장된 값을 이 주소에 저장
- 한 레지스터에 적힌 값이 1이면 바로 다음 명령을 실행하지 말고 명시된 다른 명령을 실행

⇒ 이러한 명령들의 모임을 ISA라고 함

이러한 명령들은 0과 1로 이뤄진 기계어로, 이를 사람이 쉽게 읽을 수 있도록 대응시킨 언어가 Assembly 언어

## 파이프라이닝

- CPU의 효율성을 높이는 방법
- 하나의 작업을 여러 단계로 분리한 뒤 동시 처리 가능한 일은 동시에 처리
    - e.g. 빨래하는 과정이 **세탁기 → 건조기 → 갬 → 옷장 수납** 이고 빨래의 양이 너무 많아 세탁기를 한 번에 돌릴 수 없다고 보자. 세탁기에 넣은 빨래가 모든 과정을 끝내고 옷장에 들어간 다음 빨래를 세탁기에 넣기 보다는, 세탁기에 넣은 빨래가 세탁이 끝나고 건조기에 들어가면 바로 다음 빨래를 세탁기에 넣는 것이 효율적
- 작업을 분리하는 과정에서 Hazard가 발생하고 이를 처리하는 것이 포인트

# 3. 메모리

- 메모리에는 주소가 있고, 각 주소마다 값을 저장
- CPU가 요청한 주소의 값을 알려주거나, 반대로 CPU가 알려준 주소에 새로운 값을 저장하는 역할

## 가상 메모리

여러 개의 프로그램이 동시에 실행되려면 각 프로그램의 명령과 데이터가 서로 다른 위치에 저장되어야 함

OS의 주요 기능 중 하나인 가상 메모리는 프로그램에 **가상 주소 공간**을 제공

프로그램이 가상 주소 공간에서 값을 읽고 쓰면, OS는 가상 주소를 실제 메모리의 물리적 주소로 변환

→ 서로 다른 가상 주소 공간의 가상 주소들은 서로 다른 물리적 주소에 대응 됨

⇒ 실제로는 메모리 위에서 여러 프로그램이 동시에 실행되더라도, 각 프로그램은 **혼자서 메모리를 사용하는 것처럼 보임**

## 메모리 계층구조

속도가 빠른 저장 장치일수록 비싸고 용량이 작고 에너지를 많이 소모하기 때문에 성능이 높은 것부터 낮은 것까지 다양한 종류의 저장 장치를 함께 사용

![image](https://github.com/user-attachments/assets/65ab8333-a38e-44f1-b95e-5eb204a495d2)

CPU에서 모든 데이터를 처리하기 때문에 저장 장치의 성능이 좋을수록 CPU와 가깝게 설계됨

## 지역성 (Locality)

CPU가 메모리에 저장된 데이터를 읽어올 때, `메모리 지역성`을 활용해 성능을 개선

- 처음보는 데이터보다 이전에 한 번 읽어온 데이터를 다시 읽어올 가능성이 높음
- 이미 읽어온 데이터 근처에 있는 데이터를 읽어올 가능성이 높음

→ **Cache Memory** 활용 - CPU가 데이터를 읽어올 때 주변에 있는 데이터까지 임시로 저장됨

# 4. ISA (Instruction Set Architecture)

SW와 HW가 소통하기 위해 사용하는 명령어의 집합

- CPU(HW)가 이해할 수 있는 기계어 수준의 명령들의 표준
- 프로그래머가 ISA 기준으로 프로그램을 짜면, HW는 ISA에 따라 명령을 실행함
- HW가 바뀌어도 ISA가 유지되면 기존 프로그램을 그대로 실행할 수 있음 (호환성)
- 컴파일러와 같은 도구도 ISA 기준으로 만들어짐

## 구성 요소

- **명령어 형식** : 명령어의 길이와 각 필드(opcode + operand 등) 위치 정의
- **명령어 집합** : 프로세서가 이해하고 실행할 수 있는 모든 명령어의 목록 정의. 산술 연산, 논리 연산, 데이터 전송, 제어 명령 등
- **레지스터 집합 :** 연산에 사용되는 내부 저장공간(예: x86의 eax, ARM의 x0~x30 등) 목록 정의
- **메모리 주소 지정 방식** : 데이터를 어디서 어떻게 가져올지 (Immediate, Direct, Indirect 등)
- **데이터 타입** : 프로세서가 처리할 수 있는 데이터 종류 정의. 정수, 실수, 문자, 논리값 등 포함
- **인터럽트와 예외** : 프로세서가 외부 신호나 오류 조건을 처리하는 방식 정의

## 대표적 예시
- **x86** (CISC 구조 - 복잡, 다양)
    - Intel, AMD 계열
- **ARM** (RISC 구조 - 간단, 전력 효율)
    - 모바일, IoT 중심
- **RISC-V** (RISC 구조)
    - 오픈소스 (교육·연구·산업에서 주목, e.g. xv6)
# 5. CISC vs RISC

CPU 설계 방법

## CISC (Complex Instruction Set Computer)

- 한 명령어로 여러 동작을 수행할 수 있음
    - `ADD` [m1] [m2] → m3
- 코드 길이는 짧지만 복잡한 명령은 속도가 저하되거나 설계가 어려움

## RISC (Reduced Instruction Set Computer)

- 단순한 명령어
    - `LOAD`
    - `ADD`
    - `STORE`
- HW가 빠르게 처리 가능
- 파이프라이닝, 병렬 처리에 유리
- 대부분의 스마트폰, 임베디드 장치에 사용

|  | CISC | RISC |
| --- | --- | --- |
| 명령어 수 | 많음 (수백 개 이상) | 적음 (수십 개 기준) |
| 명령어 길이 | 가변 | 고정 |
| 실행 속도 | 명령어마다 다름 | 대부분 1클럭 |
| 구현 난이도 | HW 처리 복잡, Compiler 단순 | HW 처리 단순, Compiler 복잡 |
| 파이프라이닝 | 어려움 | 최적화됨 |
| 메모리 접근 | 다양한 명령어를 통해 접근 가능 | `LOAD`와 `STORE`만 가능 |
| 대표 예시 | x86, Intel 8086 | ARM, RISC-V |

# 6. 폰 노이만 구조

> 1. 명령어와 데이터를 **하나의 메모리**에 저장
> 2. CPU가 순차적으로 이를 처리하는(명령어 사이클) 전통적인 컴퓨터 구조

- 현대 컴퓨터 대부분의 기본 모델
- 데이터와 명령어가 하나의 메모리에 있음 (같은 버스 공유) → 구조가 단순하고 설계가 쉬움
- **`폰 노이만 병목`** : 모든 데이터를 메모리에서 꺼내서 처리 →메모리와 CPU의 처리 속도 차이 발생
    - CPU가 메모리의 응답까지 대기하게 됨

## 구성 요소

| 구성요소 | 설명 |
| --- | --- |
| **CPU** | 명령어 처리 (해석, 계산, 실행) (내부 ALU, 제어장치 포함) |
| **Memory** | 명령어, 데이터를 저장하는 하나의 공간 |
| **I/O device** | 사용자와 컴퓨터 간 입출력 통로 |
| **(Bus)** | 데이터, 주소, 제어 정보를 전달하는 통신 경로 |

## 동작 과정 (명령어 사이클)

![image](https://github.com/user-attachments/assets/47656e87-d622-428d-8757-8b47e57030de)

1. I/O 장치로부터 처리할 명령과 데이터를 메모리에 불러옴
2. `Fetch` : CPU는 메모리에서 명령을 순서대로 읽고,

    `Decode` : 할 일 (메모리에 불러올 값, 연산 종류, 연산 방법, 레지스터 종류, 저장 방법 등)을 명시함
3. `Execute` & `Memory Access` : 명령 처리 (ALU 등 연산 장치로 실제 연산 수행) + (필요시 메모리에서 데이터를 읽거나 저장) 후
   
    `Writeback` : 연산 결과 값은 레지스터 등 메모리에 저장됨
5. 다시 I/O 장치를 통해 출력됨

💡 **참고**

CPU는 내부적으로 PC(ProgramCounter)를 통해 명령어 위치를 추적하고, <br>
메모리 접근 명령에서 주소 연산을 통해 데이터를 구분함. <br>
(하버드 구조와 같이 명령어와 데이터가 물리적으로 분리된 경우는 아예 버스 구조 자체가 다름)


# 7. 하버드 구조

> 1. 명령어와 데이터를 **서로 다른 메모리와 버스에 분리**해서 저장하고 처리하는 구조
> 2. CPU는 동시에 명령어를 읽고 데이터에 접근할 수 있음

- 폰 노이만 병목 현상을 완화하기 위해 다양한 방법과 구조가 등장 <br>
(메모리 계층 - 캐시, 파이프라이닝, 하버드 구조 등)

## 구성 요소

![image](https://github.com/user-attachments/assets/b0dfea2d-06f2-46ce-9f4e-867f52c2be83)


| 구성 요소 | 설명 |
| --- | --- |
| CPU | 명령과 데이터 각각 처리 가능 |
| Instruction Memory | 명령어만 저장하는 메모리 |
| Data Memory | 데이터만 저장하는 메모리 |
| (Separate Buses) | 명령어용 버스, 데이터용 버스가 따로 존재 |
- 속도 면에서 성능 향상. 설계는 복잡
- 병렬성과 처리량이 중요한 시스템에서 효과적
- e.g. 임베디드 시스템(마이크로 컨트롤러, DSP)이나 일부 RISC 아키텍처 내부에서 사용
