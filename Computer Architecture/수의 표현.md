# 수의 표현

> 컴퓨터는 음수를 어떻게 저장할까? 
>
예를 들어, 4 비트가 있다면 0에서 15까지 총 16개의 양수를 표현할 수 있다. </br>
하지만 음수는 어떻게 저장할까? </br>

→ 음수를 표현할 수 있는 <u>**부호 비트**</u>를 사용한다. </br>
다시 말해 4 비트가 있다면, (맨 앞의) 최상위 1 비트는 부호를 표현하는 데 사용하고, 나머지 3 비트로 숫자를 표현해 -8부터 7까지의 정수를 표현할 수 있다. (부호 비트가 0이면 양수, 1이면 음수)

그런데 과연 이렇게 부호 비트만 쓰면 모두 음수로 바로 표현이 가능할까? </br>
우선 컴퓨터는 덧셈만으로 연산하기 때문에 `4 - 2 = 4 + (-2)`로 계산할 것이다. </br>
그럼 이제 `4 + (-2)`를 연산해보자. </br>
만약 -2가 단순히 2 (0010)에서 부호 비트만 1로 바꾼 1010이라면 
0100 + 1010 = 1110이 되고, 원래 원하던 값인 2와는 완전히 다른 값이 나온다. </br> </br>

> 뺄셈을 음수의 덧셈으로 계산하려면?

이러한 계산을 할 수 있도록 고안해 나온 수학적 방법이 바로 **보수**다. </br>
보수는 어떤 수를 보완하는 수로, 예를 들어, `x`의 10의 보수는 x에 y를 더해 각 자리마다 자리 올림이 발생하고 자릿수가 0이 되게 하는 수 `y`를 말한다. 즉즉, `12`의 10의 보수는 `88`이다. </br>

이런 방법이 어떻게 뺄셈을 음수의 덧셈으로 계산하는 데 도움이 될까? </br>
우선, 쉬운 이해를 위해 다음 10진수에서의 예시를 살펴보자. </br>
- `4321 - 1234`를 계산해보자. </br>
1. 덧셈 연산만을 사용하기 위해서 `1234`의 <u>10의 보수</u>를 구한다. → `8766` </br>
(`1234`의 <u>9의 보수</u>인 `8765`에서 `1`을 더한 값이라고 볼 수도 있음)
2. `4321 + 8766 = 13087`
3. 넘친 부분인 맨 앞자리는 버린다. → `3087` </br>
실제 `4321 - 1234`를 뺄셈 연산해보면 같은 `3087`이 나옴을 알 수 있다. 

</br>

이 원리를 그대로 2진수로 확장한 것이 바로 2의 보수이다.


</br>

# 2의 보수

2의 보수를 활용하면 음수를 양수처럼 사용할 수 있다.


| 10진수 | 2진수 | 10진수 | 2진수 |
| --- | --- | --- | --- |
| -8 | 1000 | 0 | 0000 |
| -7 | 1001 | 1 | 0001 |
| -6 | 1010 | 2 | 0010 |
| -5 | 1011 | 3 | 0011 |
| -4 | 1100 | 4 | 0100 |
| -3 | 1101 | 5 | 0101 |
| -2 | 1110 | 6 | 0110 |
| -1 | 1111 | 7 | 0111 |

</br>

그럼 2의 보수는 어떻게 구할까? </br>
→ (10의 보수가 9의 보수에 1을 더한 값인 것처럼) 2의 보수 역시 **1의 보수에 1을 더한 값**과 같다. </br>

`x`의 **1의 보수**는 어떤 수 x에 어떤 수 y를 더해 각 자리마다 자리 올림이 있고 자릿수는 0이 되도록 하는 수 `y`를 의미한다. 즉, 1100의 1의 보수는 0011이다.  </br>
이는 곧 **NOT 연산**과 같다.
</br></br>


## 2의 보수 연산

> **= (NOT 연산) + 1** 

- 예시 1) 10진수 <u>`-7`을 2진수로 표현</u>해보자.
1. 우선, -7의 절댓값인 `7`의 2진수를 구한다. → `111`
2. **NOT** 연산을 한다. → `000`
3. **+ 1** → `001`
4. 부호 비트는 음수인 1로 설정한다. → `1001`
</br>
</br>

또다른 관점으로 봤을 때, 부호 비트를 제외하고 표현 가능한 비트가 3비트로 정수 절댓값 8까지 표현이 가능하다면, <u>표현 가능 숫자(8)</u>에서 <u>구하려는 값(-7)의 절댓값(7)</u>을 <u>뺀 수(1)</u>의 2진수(001)를 구하고, 부호 비트만 음수로 설정한 것과 같다. </br>

즉, n비트가 있을 때, `x`의 2의 보수는 `2ⁿ - x`이다. </br>
반대로, x의 2의 보수인 `2ⁿ - x`의 2의 보수는 `2ⁿ - (2ⁿ - x)`이므로 `x`가 된다.
</br></br>
      
- 예시 2) 부호 있는 2진수 `1111 1111 1111 0100`의 10진수는?
1. 부호 비트는 제외하고 먼저 연산
2. 음수의 2의 보수를 복원하려면 → **다시 한번 2의 보수 취해주면 됨** </br>
`000 0000 0000 1011 + 1` = `000 0000 0000 1100` (= `12`)
3. 부호 비트 1에 따라 음수로 설정 → `-12`
</br></br></br>

---

</br>

> 컴퓨터는 실수를 어떻게 표현할까? 
>
컴퓨터에서 실수를 표현하는 방법은 크게 두 가지로 나뉜다. </br>
소수점의 위치를 미리 정해두는 방식인 **고정 소수점**과, 지수의 값에 따라 소수점의 위치를 움직이는 방식인 **부동 소수점**이다.
</br></br>

# 고정소수점 vs 부동소수점

## 고정소수점(Fixed Point)

소수점의 위치를 정해둔다는 말은, **부호** 비트와 **정수부** 비트와 **소수부** 비트 3가지 요소의 크기를 미리 정해둔다는 것이다. 예를 들어, -3.141592는 부호(-)와 정수부(3), 소수부(0.141592)로 나눠 표현한다.

**장점** : 단순하고 간단 </br>
**단점** : 표현의 범위가 너무 작아서 활용하기 힘듦 <span style="color:gray"> (float의 경우: 정수부는 15bit, 소수부는 16bit)</span> </br>
→ 리소스가 제한적이고 높은 정밀도가 필요하지 않은 소규모 시스템에서만 간혹 사용된다. 


## 부동소수점(Floating Point)

> 다양한 부동소수점 표현 방식이 있지만 대부분 시스템의 표준(Java 포함)인 **IEEE 754** 기준
> 
소수점의 위치를 미리 정해두지 않고, 지수에 따라 결정한다.
- 가수 : 실수의 실제값 표현
- 지수 : 크기를 표현함. 가수의 어디쯤에 소수점이 있는지 나타냄

**장점** : 고정 소수점 방식보다 훨씬 더 많은 범위를 표현 가능 <span style="color:gray"> (현재 대부분 시스템에서 사용) </span> </br>
**단점** : 항상 오차 존재

</br>
</br>

# 부동소수점의 표현

## 부동소수점의 정규화

> = 가수의 첫번째 자리가 밑수보다 작은 **한자리 자연수**로 바꾸는 것

10진수 `12.345`로 예를 들면, 가수부 첫번째 자리수는 12이고 밑수는 10이므로 가수가 밑수보다 크다. 가수가 밑수보다 작도록 가수의 소수점을 한 자리 위로 올려 `1.2345`로 만드는 것이다.

### 2진수 

> 예를 들어, 10진수 `12.375`라는 숫자를 표현한다고 해보자. </br>

1. 10진수를 2진수 고정소수점으로 표현
    - `12`를 2진수로 변환하면 `1100`
    - `0.375`를 2진수로 변환하면 `0.011`

    → `12.375`는 2진수 고정소수점 표현으로 `1100.011`이다. </br>

    > 10진수 정수를 2진수로 변환하는 방법은 2로 나누면서 나머지를 차례대로 읽는 것이고, </br>
10진수 실수를 2진수로 변환하는 방법은 2를 곱하면서 정수부를 차례로 읽는 것이다. </br> 
> 

</br>

2. 부동소수점 정규화
    - 1100.011의 가수부를 밑인 2보다 작게 함 <span style="color:gray"> (항상 1) </span> </br>
    - 소수점을 움직인 만큼 지수로 표현 </br>
    → **1**.100011 * 2^3
    
    → `12.375`를 부동소수점으로 표현하면 **`1.100011 * 2^3`** 이 된다.

    이렇게 정규화 과정을 거치게 되면 2진수에서 가수부는 언제나 1로 시작하는 수가 되기 때문에 **가수부의 첫 번째 자리는 생략**이 가능해 더 많은 가수부를 저장할 수 있다.

</br>

## 부동소수점의 비트 표현

- float(32bit): 부호(1bit) + 지수(8bit) + 가수(23bit)
- double(64bit): 부호(1bit) + 지수(11bit) + 가수(52bit)

| 기호 | 의미 | 설명 |
| --- | --- | --- |
| S | 부호(Sign) | 0이면 양수, 1이면 음수 |
| E | 지수부(Exponent) | 부호있는 정수. 지수 범위는 -127~128(float), -1023~1024(double) |
| M | 가수부(Mantissa) | 실제 값을 저장하는 부분. |

</br>

> 위 예시의 `12.375`를 부동소수점으로 표현한 **1.100011 * 2^3**를 비트 표현으로 나타내보자.

1. 양수이므로 가장 처음 비트는 0
2. 가수부 비트에 실수값(`100011`)을 그대로 넣음 </br>
왼쪽부터 차례로 넣고 나머지는 0으로 채움 </br>
→ **`100011`**`00...0` (총 23 bit)
    
3. 지수에 Bias 값(float:`127`)을 더하고 지수부 비트에 넣음 </br>
→ 3 + 127 = 130 (`1000 0010`)
    
→ **`0 / 1000 0010 / 100 0110 0000 0000 0000 0000`** </br></br>

### **Bias**

**지수가 음수인 경우에** 지수의 부호 비트 없이 표현하기 위해 Bias를 사용한다. </br>
지수 값에 특정 값(Bias)을 더해서 지수의 양수/음수 값을 표현한다는 것이다. </br>
즉, **전체 지수 값을 양수로 밀어버린다**고 생각하면 된다.  </br>

지수의 값은 2^(비트 수)만큼 표현될 수 있다. </br>
그 절반에서 1을 뺀(0 한 개 제외) 값을 Bias 상수  </br>
→ float의 지수부는 8비트로, 해당 bias는 2^7 - 1인 127이다.

> 지수가 음수인 경우? </br>

예를 들어, 0.000101(2)이라는 이진수가 있다고 하자. </br>
이를 1.xxxx... * 2^n 형식으로 표현하기 위해선, `1.01 * 2^(-4)`가 된다. </br>
이 `-4` 음수 지수를 8자리 비트로 표현하기 위해, 계산된 지수에 bias(127) 값을 더하여, **0~127 구간은 음수, 128~255 구간은 양수**를 표현하도록 만든 것이다.</br> : 127보다 작으면 음수, 127보다 크면 양수로 구분할 수 있다. 
    
> 그렇다면 부호 비트를 사용해 음수 표현이 가능한데 굳이 Bias를 쓰는 이유가 무엇일까?
> 

**비교 연산이 쉬워짐**

부동소수점 숫자들은 **비트 단위로 정렬/비교**될 때 지수 크기 비교가 매우 중요 </br>
- Bias를 쓰면 지수가 **항상 양수**가 되어 두 숫자를 **비트 비교만으로 정렬 가능**     
- 바이어스 사용: `00000000`(가장 작은 지수) ~ `11111111`(특수 값들 지수) </br>
: 숫자 크기가 클수록 비트값도 커짐 → 간단하게 정렬 가능


반면 2의 보수 방식은 음수가 앞에 있고 양수가 뒤에 와서 비교 복잡

</br>

## 부동 소수점의 오차

아무리 큰 수를 저장하는 부동 소수점 방식이어도 0.1과 같이 0.00011001100….(2)로 무한 반복되는 무한 소수는 저장할 수 없다. 결국 메모리 한계까지 소수점을 집어넣고 어느 부분에서 끊어서 반올림해야한다.

- 실수의 소수점을 표현할 수 있는 수의 제한이 존재  ⇒  계산의 오차 발생
    

```java
double value1 = 12.23;
double value2 = 34.45;

// 기대값 : 46.68
System.out.println(value1 + value2); // 46.68000000000001
```

금융권이나 회계, 미사일 등 정확한 계산이 필요한 곳에서는 특히 주의해야 한다. </br>
Java에서는 **BigDecimal** 클래스를 이용해 문제를 해결할 수 있다. Python에서도 **Decimal**을 사용해 정확한 계산을 실행할 수 있다. **BigDecimal**은 정수부, 소수부를 모두 10진수로 표현한다. 오차 없이 연산 가능하지만 부동소수점에 비해 메모리가 많이 사용된다는 단점이 있다. 

또한 소수를 정수로 바꿔서 계산하는 방법도 있다. : **0.00000001비트코인 = 1 사토시**




</br>

---
</br>

**References**

https://devraphy.tistory.com/282

https://gsmesie692.tistory.com/94

https://devocean.sk.com/blog/techBoardDetail.do?ID=165270&boardType=techBlog

https://inpa.tistory.com/entry/JAVA-%E2%98%95-%EC%8B%A4%EC%88%98-%ED%91%9C%ED%98%84%EB%B6%80%EB%8F%99-%EC%86%8C%EC%88%98%EC%A0%90-%EC%9B%90%EB%A6%AC-%ED%95%9C%EB%88%88%EC%97%90-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0